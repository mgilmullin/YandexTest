# -*- coding: utf-8 -*-
# Author: Mansur Gilmullin


# ----------------------------------------------------------------------------------------------------------------------
# Подготовка к собеседованию в Яндекс: задача "G. Интересное путешествие"
# ----------------------------------------------------------------------------------------------------------------------
# Не секрет, что некоторые программисты очень любят путешествовать. Хорошо всем известный программист Петя тоже очень
# любит путешествовать, посещать музеи и осматривать достопримечательности других городов.
# Для перемещений между из города в город он предпочитает использовать машину. При этом он заправляется только на
# станциях в городах, но не на станциях по пути. Поэтому он очень аккуратно выбирает маршруты, чтобы машина не заглохла
# в дороге. А ещё Петя очень важный член команды, поэтому он не может себе позволить путешествовать слишком долго.
# Он решил написать программу, которая поможет ему с выбором очередного путешествия. Но так как сейчас у него слишком
# много других задач, он попросил вас помочь ему.
# Расстояние между двумя городами считается как сумма модулей разности по каждой из координат.
# Дороги есть между всеми парами городов.
# ----------------------------------------------------------------------------------------------------------------------
# Формат ввода:
# В первой строке входных данных записано количество городов n (2 ≤ n ≤ 1000). В следующих n строках даны два целых
# числа: координаты каждого города, не превосходящие по модулю миллиарда. Все города пронумерованы числами от 1 до n
# в порядке записи во входных данных.
# В следующей строке записано целое положительное число k, не превосходящее двух миллиардов, — максимальное расстояние
# между городами, которое Петя может преодолеть без дозаправки машины.
# В последней строке записаны два различных числа — номер города, откуда едет Петя, и номер города, куда он едет.
# ----------------------------------------------------------------------------------------------------------------------
# Формат вывода:
# Если существуют пути, удовлетворяющие описанным выше условиям, то выведите минимальное количество дорог, которое нужно
# проехать, чтобы попасть из начальной точки маршрута в конечную. Если пути не существует, выведите -1.
# ----------------------------------------------------------------------------------------------------------------------
# Пример 1:
# Ввод	Вывод
# 7     2
# 0 0
# 0 2
# 2 2
# 0 -2
# 2 -2
# 2 -1
# 2 1
# 2
# 1 3
# ----------------------------------------------------------------------------------------------------------------------
# Пример 2
# Ввод	Вывод
# 4     1
# 0 0
# 1 0
# 0 1
# 1 1
# 2
# 1 4
# ----------------------------------------------------------------------------------------------------------------------
# Пример 3
# Ввод	Вывод
# 4     -1
# 0 0
# 2 0
# 0 2
# 2 2
# 1
# 1 4
# ----------------------------------------------------------------------------------------------------------------------
# Есть описание одного алгоритма решения, попытаемся его реализовать: https://habr.com/ru/company/yandex/blog/340784/
# Вначале из имеющихся точек нужно построить граф. Для этого переберем все пары точек и, если расстояние между ними
# меньше заданного ограничения, добавим в граф ребро между вершинами. После построения графа запустим поиск в ширину BFS
# из города, откуда Петя начинает свое путешествие. Как только он достигнет точки назначения, завершим наш алгоритм
# и выведем количество пройденных нами ребер. Если алгоритм завершился, а мы так и не достигли пункта назначения,
# то он недостижим из исходного города, поэтому следует вывести -1. Общая сложность описанного алгоритма — O(n^2),
# где n — число городов.
# ----------------------------------------------------------------------------------------------------------------------


def L1Range(a, b):
    """
    Считаем "метрику городских кварталов" L1:
    https://ru.wikipedia.org/wiki/Расстояние_городских_кварталов

    :param a: a = (x1, y1) - tuple with 1st coordinates
    :param b: b = (x2, y2) - tuple with 2nd coordinates
    :return: integer number
    """
    return abs(b[0] - a[0]) + abs(b[1] - a[1])


def BFS(s, adjacencyList):
    """
    Алгоритм поиска в ширину (BFS). Он позволяет за время O(E), где Е - количество рёбер в графе, проверить достижимость
    любой вершины v из стартовой вершины s, а также посчитать минимальное количество рёбер, необходимое для этого (стоимость пути).

    :param s: int, индекс стартовой вершины графа.
    :param adjacencyList: List[List[int]], матрица смежности вершин графа (вершины, которые достижимы из каждой конкретной вершины).
    :return: List[int], "стоимости" путей до всех вершин - минимальное количество ребёр графа, чтобы достигнуть каждую вершину из стартовой.
    """
    costs = [-1] * len(adjacencyList)  # стоимость прохода до нужной вершины
    costs[s] = 0  # стоимость пути из любой вершины графа в саму себя равна нулю
    queue = [s]  # для простоты создаём очередь в виде List, но для оптимизации лучше использовать связный список, например, queue.Queue()

    while queue:
        v = queue.pop(0)
        # запускаем алгоритм обхода по вершинам графа:
        for u in adjacencyList[v]:
            # проверяем каждую вершину, посещали её или нет:
            if costs[u] == -1:
                queue.append(u)  # если вершина не посещалась, добавляем её в очередь
                costs[u] = costs[v] + 1  # увеличиваем стоимость пути

    return costs


def Task6(inpFile="input.txt"):
    # получаем входные параметры из файла:
    with open(inpFile, "r", encoding="UTF-8") as fH:
        inpLines = fH.readlines()  # строки исходного входного файла
        # удаляем ненужное окончание строк и читаем строки как числа:
        n = int(inpLines[0])  # количество городов n (2 <= n <= 1000). Важно! Города пронумерованы от 1 до n
        coordList = []  # сохраняем координаты как list of tuples

        for item in inpLines[1: -2]:
            # координата очередного города:
            coordList.append(
                (
                    int(item.split(" ")[0]),
                    int(item.split(" ")[1].rstrip("\n"))
                )
            )

        k = int(inpLines[-2])  # число k <= 2 млрд., максимальное расстояние между городами, которое Петя может преодолеть без дозаправки машины

        # читаем номера городов - начала и конца пути:
        path = (
            int(inpLines[-1].split(" ")[0]),
            int(inpLines[-1].split(" ")[1].rstrip("\n"))
        )

        # print("n =", n)
        # print("coordList = ", coordList)
        # print("k =", k)
        # print("path =", path)

    city1Coord = coordList[path[0] - 1]  # координата первого города по индексу из списка всех городов
    city2Coord = coordList[path[1] - 1]  # координата второго города по индексу из списка всех городов

    # print("city1Coord =", city1Coord)
    # print("city2Coord =", city2Coord)

    # Если расстояние между 1 и 2 городами сразу меньше либо равно k (доступный бензин), то путь сразу равен 1
    if L1Range(city1Coord, city2Coord) <= k:
        result = 1

    else:
        # Предварительно создаём список достижимости городов - это матрица смежности каждого города с каждым другим городом,
        # если до него хватает бензина. В список заносим только индексы достижимых городов.
        # Если начальный и конечный город совпадают, отмечаем это как достижимый город.
        adjList = [
            [index for index, city1 in enumerate(coordList) if L1Range(city1, city2) <= k] for city2 in coordList
        ]

        # print("adjList =", adjList)

        # считаем стоимости всех путей из стартового города до всех остальных достижимых городов:
        costs = BFS(s=path[0] - 1, adjacencyList=adjList)

        # print("costs =", costs)

        # получаем стоимость пути до конечного города, -1 если такого пути нет, либо он недостижим:
        result = costs[path[1] - 1]

    with open("output.txt", "w", encoding="UTF-8") as fH:
        fH.write(str(result))

    return result


if __name__ == "__main__":
    print(Task6(inpFile="input.txt"))
