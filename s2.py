# -*- coding: utf-8 -*-
# Author: Mansur Gilmullin


# ----------------------------------------------------------------------------------------------------------------------
# Подготовка к собеседованию в Яндекс: задача "B. Последовательно идущие единицы"
# ----------------------------------------------------------------------------------------------------------------------
# Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.
# Желательно получить решение, работающее за линейное время и при этом проходящее по входному массиву только один раз.
# ----------------------------------------------------------------------------------------------------------------------
# Формат ввода:
# Первая строка входного файла содержит одно число n, n ≤ 10000. Каждая из следующих n строк содержит ровно одно число —
# очередной элемент массива.
# ----------------------------------------------------------------------------------------------------------------------
# Формат вывода:
# Выходной файл должен содержать единственное число — длину самой длинной последовательности единиц во входном массиве.
# ----------------------------------------------------------------------------------------------------------------------
# Пример:
# Ввод	Вывод
# 5     1
# 1
# 0
# 1
# 0
# 1
# ----------------------------------------------------------------------------------------------------------------------


def Task2(inpFile="input.txt"):
    # получаем входные параметры из файла:
    with open(inpFile, "r", encoding="UTF-8") as fH:
        inpLines = fH.readlines()  # строки исходного входного файла
        # удаляем ненужное окончание строки и читаем строки как числа:
        for i, item in enumerate(inpLines):
            try:
                inpLines[i] = int(item.rstrip("\n"))

            except Exception as e:
                inpLines[i] = item.rstrip("\n")

    # print(inpLines)
    n = inpLines[0]  # число n <= 10000
    v = inpLines[1:]  # вектор, содержащий элементы массива
    # print(n)
    # print(v)

    result = 0  # счётчик для максимального количества подряд идущих единиц
    subItems = 0  # промежуточный счётчик для подстрок, содержащих только единицы
    i = 0  # счётчик элементов
    while i < n:
        if v[i] == 1:
            subItems += 1

        else:
            result = max(result, subItems)  # берём максимальное значение предыдущей длины и текущей найденной
            subItems = 0

        i += 1

    result = max(result, subItems)  # учитываем последнюю итерацию в цикле, сравниваем на всякий случай

    with open("output.txt", "w", encoding="UTF-8") as fH:
        fH.write(str(result))

    return result


if __name__ == "__main__":
    print(Task2(inpFile="input.txt"))
